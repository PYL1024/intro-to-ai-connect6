# 路表、博弈树与威胁空间搜索（代码版说明）

## 一、棋盘“路”的定义与评估作用
  - 全局评估：`V1Board.evaluateBoard()` 聚合所有有效路分，得到 `boardScoreMy - boardScoreOpp`。
  - 增量评估：`evaluateMoveIncrement()` 仅重算经过目标格子的路，快速估算落子得失，支撑着法排序、α-β 节点评估、TBS 威胁筛选。
  - 剪枝辅助：路失效（双方同路有子）立即降分，为搜索剪枝提供单调性。

## 二、α-β剪枝与实现要点
  - 搜索：迭代加深 + 主变量搜索(PVS)，首子全窗口，后续空窗口试探失败再全搜。
  - 启发：路表增量分、历史表、杀手表、位置分，动态限制候选双子数，优先高价值分支以提升剪枝率。
  - 威胁延伸：落子触发致命威胁（冲四/活四/复合威胁）时深度+1，减少漏判。
  - 回溯：使用 `V1Board.captureStateForSearch()/restoreStateForSearch()` 与 `updateLinesAfterMove()/undoLinesAfterMove()`，保证候选、边界、路表均被正确复原。
  - 本次更新（V3.1）：置换表（TT）+ Zobrist 哈希；LMR（晚着法降低）与静态延伸（Quiescence）；双子协同评分（同一路/潜在双威胁加分）。

## 三、威胁空间搜索（Threat Based Search, TBS）
  - 威胁筛选：调用 `MoveGenerator.generateMoves()` 取高分着法，模拟落子后用 `ThreatAnalyzer.analyzeThreat()` 评估双冲四/冲四活三/双活三等强威胁，只保留威胁性着法。
  - 防守生成：`ThreatEvaluator.getDefensePositions(attackerColor)` 提取必堵点，若不足两点则为其拼最佳搭档；再补充少量高分防守/反击着法防止漏搜。
  - 递归：`searchAttacks()` 与 `searchDefenses()` 交替，深度耗尽时检查是否存在即时胜着；无防守点视为威胁不可挡。
  - 状态：与 α-β 共用路表/候选回溯接口，搜索前自动 `buildLines()` 以启用增量评估。
  - 本次更新：加入 Zobrist 哈希与结果/防守缓存，剪同型与复用计算，降低分支与重复搜索；不可挡判定（必堵点>2）早停。

## 四、改进点与优缺点
  - 优点：配合启发剪枝深度可控、稳定；TT/Zobrist 显著减少重复搜索；LMR+静态延伸在战术敏感处平衡速度与质量。
  - 缺点：在复杂强制序列中仍可能深度不足，需要威胁延伸或专用搜索补足。
  - 优点：专门处理强制威胁链，能提前宣布胜势或找到唯一防点；加入哈希与缓存后分支与重复计算显著减少。
  - 缺点：对威胁判定依赖准确性；需时间/深度剪裁与缓存策略防止误导；不可挡判定需结合更细的威胁聚类防止误判。
  - 优点：全局与增量评估统一，支持搜索回溯；协同评分与阻断加权提升实战排序质量。
  - 缺点：内存开销增加，需谨慎维护有效性（双方同路即失效）。

## 五、关键数据结构与性能影响

## 六、小结
本文档已合并至 README，请查看：

- 统一文档：README.md
